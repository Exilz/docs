---
title: 'Comparing columns of same table through raw queries'
metaTitle: 'Comparing columns of same table through raw queries'
metaDescription: 'Comparing columns of same table through raw queries'
---

## Workaround

Comparing columns from a same table is a common scenario which developers have to deal with. Some examples of it could be comparing two numeric values in a same table or comparing two dates in a same table.


## Solution

This could be achieved by using [Raw query](https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access)

A use case could be of getting posts which has more comments than likes, In this case we need to compare commentsCount and likesCount.

```prisma
model Post {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  title         String   
  content       String?
  published     Boolean  @default(false)
  author        User     @relation(fields: [authorId], references: [id])
  authorId      Int
  likesCount    Int
  commentsCount Int
}
```

Queries depending upon databases could look something like:

*PostgreSQL / CockroachDB*

```js
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateNumbersComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "public"."Post" WHERE "likesCount" < "commentsCount";`;

  console.log(response);
}

await initiateNumbersComparisonRawQuery();
```

*MySQL*

```js
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateNumbersComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "public"."Post" WHERE "likesCount" < "commentsCount";`;

  console.log(response);
}

await initiateNumbersComparisonRawQuery();
```

*Sqlite*

```js
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateNumbersComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "Post" WHERE "likesCount" < "commentsCount";`;

  console.log(response);
}

await initiateNumbersComparisonRawQuery();
```

Executing the above queries depending upon the database would filter posts which has less likes compared to comments.

*Query Response*

```js
[
  {
    id: 1,
    createdAt: '2022-03-03T12:08:11.421+00:00',
    updatedAt: '2022-03-03T12:08:11.422+00:00',
    title: 'Hello World',
    content: 'This is my first post',
    published: false,
    authorId: 1,
    likesCount: 50,
    commentsCount: 100
  }
]
```
---

Similarly If we need to compare dates we could achieve the same thing using raw queries as well.

A use case could be to get all the projects which are completed before the due date.

```prisma
model Project {
  id            Int      @id @default(autoincrement())
  title         String
  author        User     @relation(fields: [authorId], references: [id])
  authorId      Int
  dueDate       DateTime
  completedDate DateTime
  createdAt     DateTime @default(now())
}
```

Queries depending upon databases could look something like:

*PostgreSQL / CockroachDB*

```js
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateDatesComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "public"."Project" WHERE "completedDate" > "dueDate";`;

  console.log(response);
}

await initiateDatesComparisonRawQuery();
```

*MySQL*

```js
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateDatesComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM \`public\`.\`Project\` WHERE \`completedDate\` > \`dueDate\`;`;

  console.log(response);
}

await initiateDatesComparisonRawQuery();
```

*Sqlite*

```js
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateDatesComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM \`public\`.\`Project\` WHERE \`completedDate\` > \`dueDate\`;`;

  console.log(response);
}

await initiateDatesComparisonRawQuery();
```

Executing the above query would filter projects whose completion date is after itâ€™s due date.

*Query Response*

```js
[
  {
    id: 1,
    title: 'Project 1',
    authorId: 1,
    dueDate: '2022-03-10T00:00:00+00:00',
    completedDate: '2022-03-12T00:00:00+00:00',
    createdAt: '2022-03-03T12:08:11.421+00:00'
  }
]
```


